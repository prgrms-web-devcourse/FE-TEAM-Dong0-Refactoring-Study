# 3장

리팩터링이 어떻게 작동하는지 감이 왔을 것이다. 하지만 언제 시작하고, 언제 그만할지를 판단하는 것 또한, 리팩터링의 방법 못지 않게 중요하다.

성공한 프로젝트 부터 실패한 프로젝트까지 많은 코드를 본 결과 리팩터링이 필요한 코드들에 일정한 패턴이 있다는 사실을 발견한다.
하지만 종료 시점은 알려주지않는다.(??) 숙련된 사람의 직관으로 정한다. 종료기준보다는 리팩터링하면 해결할 수 있는 문제의 징후를 제시한다.

## 3-1 기이한 이름

코드는 단순하고 명료하게 작성해야한다. 이에 가장 중요한 요소가 이름이다. 함수, 모듈 변수, 클래스 등은 그 이름만 보고도 무슨 일을 하고, 어떻게 사용하는지 명확히 알 수 있도록 지어야한다.

**함수 선언 바꾸기**(함수 이름을 바꿀 때도 가능하다.), **변수 이름 바꾸기**, **필드 이름 바꾸기** 등 이름을 바꾸는 리팩터링을 가장 많이 사용한다. 이름만 잘 지어도 나중에 문맥을 파악하느라 헤매는 시간을 크게 절약할 수 있다.
마땅한 이름이 떠오르지 않는다면 설계에 더 근본적인 문제가 숨어 있을 가능성이 높다. 그래서 혼란스러운 이름을 잘 정리하다 보면 코드가 훨씬 간결해질 때가 많다.

## 3-2 중복 코드

똑같은 코드 구조가 여러곳에서 반복되면 하나로 통합하여 더 나은 프로그램을 만들 수 있다.가장 간단한 중복의 예로 한 클래스에 딸린 두 메서드가 똑같은 표현식을 사용하는 경우가 있다. 이럴 때는 **함수 추출하기**를 써서 양쪽 모두 추출된 메서드를 호출하게 바꾼다. 코드가 비슷하지만 완전히 똑같지 않다면 **문장 슬라이드하기**로 비슷한 부분을 한 곳에 모아 함수 추출하기를 더 쉽게 적용할 수 있는지 살펴본다.
같은 부모로부터 발생된 서브 클래스들에 코드가 중복되어 있다면, 각자 따로 호출되지 않도록 **메서드 올리기**를 적용해 부모로 옮긴다.

## 3-3 긴 함수

오랜기간 잘 활용되는 프로그램들은 하나같이 짧은 함수로 구성됐다. 간접호출의 효과, 함수를 짧게 구성할 때 코드를 이해하고, 공유하고, 선택하기 쉬워진다.
짧은 함수로 구성된 코드를 이해하기 쉽게 만드는 가장 확실한 방법은 좋은 이름이다. 함수이름을 잘 지어두면 본문 코드를 볼 이유도 사라진다.

그러기 위해 더 적극적으로 함수를 쪼개야한다. 우리는 주석을 달아야 할 만한 부분은 무조건 함수로 만든다.
그 함수 본문에는 원래 주석으로 설명하려던 코드가 담기고, 함수 이름은 동작 방식이 아닌 의도가 드러나게 짓는다.
원래 코드보다 길어지더라도 함수로 뽑아낸다. 함수를 짧게 만드는 작업의 99%는 **함수 추출하기**가 차지한다.

함수가 매개변수와 임의 변수를 많이 사용한다면 추출작업에 방해가 된다. 이런 상황에서 함수를 추출하다 보면 추출된 함수에도 매개 변수가 너무 많아져 리팩터링 전보다 난해해 진다. 이때 **임시변수를 질의 함수로 바꾸기**로 임시 변수의 수를 **매개변수 객체만들기**와 **객체 통채로 넘기기**로 매개변수의 수를 줄일 수 있다.

이 리팩터링들을 적용해도 여전히 임시변수와 매개변수가 너무 많다면 더 큰 수술인 **함수를 명령으로 바꾸기**를 고려해보자

추출할 코드 덩어리 찾기: 주석을 참고, 주석은 코드만으로는 목적을 이해하기 어려운 부분에 써있는 경우가 대부분이다. 이런경우 주석이 설명하는 코드와 함께 함수를 빼내고, 함수이름은 주석 내용을 토대로 짓는다.
조건문이나 반복문도 추출 대상을 알려주는 경우가 있다. 조건문은 **조건문 분해하기**, switch문을 구헝하는 case문마다 함수추출하기를 적용해서 각 case의 본문을 함수 호출문 하나로 바꾼다. 같은 조건을 기준으로 나뉘는 switch문이 여러개라면 **조건부 로직을 다형성으로 바꾸기**를 적용한다.

반복문도 그 안의 코드와 함께 추출해서 독립된 함수로 만든다. **반복문 쪼개기**를 적용해서 분리한다.

## 3-4 긴 매개변수 목록

우리는 함수에 필요한 것을 매개변수로 전달하라고 배웠다. 이렇게 하면 전역 데이터가 늘어나는 사태를 막을 수 있지만 매개변수 목록이 길어지면 그 자체로 이해하기 어려울 때도 많다.
종종 다른 매개변수에서 값을 얻어올 수 있는 매개변수가 있을 수 있는데, 이런 매개변수는 **매개변수를 질의 함수로 바꾸기**로 제거할 수 있다. 사용 중인 데이터 구조에서 값들을 뽑아 각각을 별개의 매개변수로 전달하는 코드라면 **객체 통채로 넘기기**를 사용해서 원본 데이터 구조를 그대로 전달한다.
항상 함께 전달 되는 매개변수는 **매개변수 객체 만들기**로 하나로 묶어 버린다. 함수의 동작방식을 정하는 플래그 역할을 하는 매개변수는 **플래그 인수 제거하기**로 없애준다.

클래스는 매개변수 목록을 줄이는 데 효과적인 수단이다. 여러개의 함수가 특정 매개변수들의 값을 공통으로 사용할 때 유용하다. 특히 여러개의 함수가 특정 매개변수들의 값을 공통으로 사용할 때 유용한데 이럴때 **여러함수를 클래스로 묶기**를 이용하여 공통 값들을 클래스의 필드로 정의한다.

## 3-5 전역 데이터

전역데이터는 코드 베이스 어디에서든 건드릴 수 있고, 값을 누가 바꿨는지 찾아낼 메커니즘이 없다는 것이 문제다. 전역 데이터의 대표적인 형태는 전역변수이지만 클래스 변수의 싱글톤에서도 같은 문제가 발 생한다. 이를 방지 하기 위해 **변수 캡슐화하기**를 사용한다.

## 3-6 가변 데이터

데이터 변경 시 다른 곳에서 버그가 발생하는 경우가 종종 있다.
이런 이유로 함수형 프로그래밍에서는 데이터는 절대 변하지 않고, 데이터를 변경하려면 반드시 변경하려는 값에 해당하는 복사본을 만들어서 반환하는 개념을 기본으로 삼고 있다.
**변수 캡슐화하기**를 적용하여 정해놓은 함수를 거처야만 값을 수정할 수 있도록 하면 값이 어떻게 수정되는지 감시하거나 코드 개선이 쉽다. 하나의 변수에 용도가 다른 값들을 저장하느라 값을 갱신하는 경우라면 **변수 쪼개기**를 사용한다.

갱신 로직은 다른 코드와 떨어뜨려 놓는 것이 좋다. 그러기 위해 **문장 슬라이드하기**와 **함수 추출하기**를 이용해서 무언가를 갱신하는 코드로 부터 부작용이 없는 코드를 분리한다. API를 만들 때는 **질의 함수와 변경 함수 분리하기** 를 통해 꼭 필요한 경우가 아니라면 부작용이 있는 코드를 호출할 수 없게 한다. 우리는 가능한 한 **세터 제거하기**도 적용한다. (setter) 값을 다른 곳에서 설정할 수 있는 가변 데이터는 더 끔찍하다. 이럴 때는 **파생변수를 질의 함수로 바꾸기**를 사용한다.
유효범위가 넓어지면 위험도 커진다. **여러 함수를 클래스로 묶기**나 **여러 함수를 변환 함수로 묶기**를 활용해서 변수를 갱신하는 코드들의 유효범위를 제한하고, 구조체처럼 필드에 데이터를 담고 있는 변수라면 일반적으로 **참조를 값으로 바꾸기**를 적용하여 내부 필드를 직접수정하지 않고, 구조체를 통채로 교체하는 것이 좋다.

---

# 나온 리팩토링 기법들

### 함수 선언 바꾸기

- 함수 이름 바꾸기
- 시그니처 바꾸기

### 변수 이름 바꾸기

### 필드 이름 바꾸기

### 함수 추출하기

### 문장 슬라이드하기

- 조건문의 공통 실행 코드
  관련된 코드들이 가까이 모여있다면 이해하기 더 쉽다. 관련 코드끼리 모으고, 명확히 구분되는 함수로 추출하는 것이 베스트이다.

  ```js
  const pricingPlan = retrivePricingPlan();
  const order = retrieveorder();
  let charge;
  const chargPerUnit = pricingPlan.unit;
  ```

  =>

  ```js
  const pricingPlan = retrivePricingPlan();
  const order = retrieveorder();
  const chargPerUnit = pricingPlan.unit;
  let charge;
  ```

### 메서드 올리기

```js
class Employee{...}
class Salesperson extends Employee{
    get name(){...}
}
class Engineer extends Employee{
    get name(){...}
}
```

=>

```js
class Employee{
    get name(){...}
}
class Salesperson extends Employee{ ... }
class Engineer extends Employee{ ... }
```

### 임시 변수를 질의 함수로 바꾸기

```js
const basePrice = this.quantity * this._itemPrice;
if (basePrice > 1000) {
  return basePrice * 0.95;
} else {
  return basePrice * 0.98;
}
```

=>

```js
get basePrice(){this.quantity * this._itemPrice;}
...
if (this.basePrice > 1000) {
  return this.basePrice * 0.95;
} else {
  return this.basePrice * 0.98;
}
```

함수 안에서 어떤 코드의 결괏값을 뒤에서 다시 참조할 목적으로 임시변수를 쓰기도 한다. 이때 임시변수를 사용하면 값을 계산하는 코드가 반복되는 것을 줄이고, 값의 의미를 설명할 수 있어 좋다. 하지만 더 나아가 아예 함수로 만들면 베스트다.

### 매개변수 객체 만들기

데이터 항목이 여러개가 몰려다니는 경우 데이터 구조 하나로 모아준다.

### 객체 통채로 넘기기

### 함수를 명령으로 바꾸기

메서드를 메서드 객체로 전환

```js
function score(candidate, medicalExam, scoringGuide) {
  let result = 0;
  let healthLevel = 0;
}
```

```js
class Scorer {
  constructor(candidate, medicalExam, scoringGuide) {
    this._candidate = candidate;
    this._medicalExam = medicalExam;
    this._scoringGuide = scoringGuide;
  }
  execute() {
    this._result = 0;
    this.healthLevel = 0;
  }
}
```

함수를 그 함수만을 위한 객체 안으로 캡슐화하면 명령이라고 한다. 명령 객체 대부분은 메서드 하나로 구성되며, 이 메서드를 요청해 실행하는 것이 이 객체의 목적이다.

### 조건문 분해하기

### 조건부 로직을 다형성으로 바꾸기

### 반복문 쪼개기

### 매개변수를 질의 함수로 바꾸기

### 매개변수 객체 만들기

### 플래그 인수 제거하기

### 여러 함수를 클래스로 묶기

### 변수 캡슐화 하기

```js
let defaultOwner = { firstName: "마틴", lastName: "파울러" };
```

=>

```js
let defaultOwnerData = { firstName: "마틴", lastName: "파울러" };
export function defaultOwner() {
  return defaultOwnerData;
}
export function setDefaultOwner(arg) {
  defaultOwnerData = arg;
}
```

함수는 데이터 보다 다루기 수월하다. (함수 이름을 바꾸거나 다른 모듈로 옮기기 등등...)

### 변수 쪼개기

### 질의 함수와 변경 함수 분리하기

### 세터(setter) 제거하기

세터가 있다는 것은 필드가 수정될 수 있다는 것이다. 객체 생성 이후 수정되지 않기 원하는 필드라면 세터를 제공하지 않을 것이다.

- 사람들이 무조건 점ㅂ근자 메서드를 통해서만 필드를 다루려 할 때
- 클라이언트에서 생성 스크립트를 사용해 객체를 생성할 때

### 파생 변수를 질의 함수로 바꾸기

```js
get discountedTotal(){return this._discountedTotal;}
set discount(aNumber){
    const old=this._discount;
    this._discount=aNumber;
    this._discountedTotal+=old-aNumber;
}
```

=>

```js
get discountedTotal(){return this._baseTotal-this._discount;}
set discount(aNumber){this._discount=aNumber}
```

가변 데이터의 유효 범위를 가능한 한 좁혀야 한다.

### 여러 함수를 클래스로 묶기

```js
function base(aReading){...}
function taxableCharge(aReading){...}
function calculateBaseCharge(aReading){...}
```

=>

```js
class Reading{
    base(){...}
    taxableCharge(){...}
    calculateBaseCharge(){...}
}
```

### 여러 함수를 변환 함수로 묶기

### 참조를 값으로 바꾸기

```

```
