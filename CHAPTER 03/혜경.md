- [리팩토링 3장](#리팩토링-3장)
  - [리팩토링을 해야 하는 경우](#리팩토링을-해야-하는-경우)
    - [1. 기이한 이름](#1-기이한-이름)
    - [2. 중복 코드](#2-중복-코드)
    - [3. 긴 함수](#3-긴-함수)
    - [4. 긴 매개변수 목록](#4-긴-매개변수-목록)
    - [5. 전역 데이터](#5-전역-데이터)
    - [6. 가변 데이터](#6-가변-데이터)
    - [7. 뒤엉킨 변경](#7-뒤엉킨-변경)
    - [8. 산탄총 수술](#8-산탄총-수술)
    - [9. 기능 편애](#9-기능-편애)
    - [10. 데이터 뭉치](#10-데이터-뭉치)
    - [11. 기본형 집착](#11-기본형-집착)
    - [12. 반복되는 switch 문](#12-반복되는-switch-문)
    - [13. 반복문](#13-반복문)
    - [14. 성의없는 요소](#14-성의없는-요소)
    - [15. 추측성 일반화](#15-추측성-일반화)
    - [16. 임시 필드](#16-임시-필드)
    - [17. 메시지 체인](#17-메시지-체인)
    - [18. 중개자](#18-중개자)
    - [19. 내부자 거래](#19-내부자-거래)
    - [20. 거대한 클래스](#20-거대한-클래스)
    - [21. 서로 다른 인터페이스의 대안 클래스들](#21-서로-다른-인터페이스의-대안-클래스들)
    - [22. 데이터 클래스](#22-데이터-클래스)
    - [23. 상속 포기](#23-상속-포기)
    - [24. 주석](#24-주석)
# 리팩토링 3장
## 리팩토링을 해야 하는 경우
### 1. 기이한 이름
이름만 보고도 무슨 일을 하고 어떻게 사용해야 하는지 명확히 알 수 있어야한다.
-> 추후에 문맥 파악에 헤매는 시간을 크게 절약할 수 있다

### 2. 중복 코드
한 클래스에 따른 두 메서드가 똑같은 표현식을 사용한다면 `함수 추출하기`를 써서 양쪽 모두 추출된 메서드를 호출하게 바꾸면 된다.

### 3. 긴 함수

짧은 함수로 구성해야한다!
-> 🤔 오히려 왔다갔다 하면서 더 이해하기 힘들진 않을까?
호출과 선언을 동시에 보여주는 개발 환경을 활용하면 이 부담이 줄어들고, 이름을 잘 지어두면 본문 코드를 볼 이유가 사라진다! 그러므로 주석을 달아야 할 부분을 함수로 만들고, 동작 방식이 아닌 `의도` 가 드러나게 지으면 됨!

=> 함수 이름에 코드의 목적을 드러내고, 무엇을 하는지가 보여야한다

😮 추출해야하는 건 알겠는데 어떤 애들을 추출하지?
주석을 참고하면 쉽다. 주석을 찾으면 주석이 설명하는 코드와 함께 함수로 빼내고 함수 이름을 주석 내용을 토대로 지으면 좋다.


### 4. 긴 매개변수 목록
함수에 필요한 것들을 모조리 매개변수로 전달할 때 매개변수 목록이 길어질수록 이해하기 어려울 때가 많다 -> 객체 통째로 넘기기를 적용해 원본 데이터 구조를 그대로 전달한다.


### 5. 전역 데이터
전역 데이터는 코드 베이스 어디에서든 건드릴 수 있고 값을 누가 바꿨는지 찾아낼 메커니즘이 없다.
-> 변수 캡슐화하기
-> 데이터를 수정하는 부분을 쉽게 찾을 수 있고 접근을 통제할 수 있게 된다

### 6. 가변 데이터
함수형 프로그래밍은 데이터는 절대 변하지 않고, 데이터를 변경하려면 반드시 (원래 데이터는 그대로 둔 채) 변경하려는 값에 해당하는 복사본을 만들어서 반환한다는 개념을 기본으로 삼고 있다.

최대한 side effect를 줄이는 방향으로 코드를 작성해야한다.
-> 문장 슬라이스하기, 함수 추출하기를 이용해서 무언가를 갱신하는 코드로부터 부작용이 없는 코드를 분리한다. 

### 7. 뒤엉킨 변경
맥락별로 처리하는 것이 좋다.
만약, 순차적으로 처리되는 로직이라면 단계를 분리한다. (단계 쪼개기)
전체 처리 과정 곳곳에서 각기 다른 맥락의 함수를 호출하는 빈도가 높다면, 각 맥락에 해당하는 적당한 모듈들을 만들어서 관련 함수들을 모은다. 그러면 처리 과정이 맥락별로 구분된다.

### 8. 산탄총 수술
함께 변경되는 대상들을 함수 옮기기와 필드 옮기기로 모두 한 모듈에 묶어둔다.
어설프게 분리된 로직을 함수 인라인하기나 클래스 인라인하기같은 인라인 리팩터링의로 하나로 합치는 것도 좋다.

### 9. 기능 편애
프로그램을 모듈화할 때 코드를 여러 영역으로 나눈 뒤 영역 안에서 이뤄지는 상호작용은 최대한 늘리고 영역 사이에서 이뤄지는 상호작용은 최소로 줄이는 데 주력한다.

함께 변경할 대상을 한데 모은다.

### 10. 데이터 뭉치
필드 형태의 데이터 뭉치를 찾아서 클래스 추출하기로 하나의 객체로 묶는다. 
데이터뭉치인지 판별하려면 값 하나를 삭제해보고, 나머지 데이터만으로 의미가 없다면 객체로 환생하길 갈망하는 데이터 뭉치라는 의미이다.

### 11. 기본형 집착
기본형 -> 객체로 바꿔야한다.
클래스 추출하기와 매개변수 만들기를 이용하면 된다.

### 12. 반복되는 switch 문
중복된 switch 문은 조건절 하나 추가할 때마다 다른 switch 문들도 모두 찾아서 함께 수정해야 하기 때문이다.

### 13. 반복문
반복문을 파이프라인(filter, map)으로 바꾸기를 적용해서 반복문을 제거한다. 

**before**
```js
    let average = 0;
    let totalSalary = 0;

    for (const p of people) {
    average += p.average;
    totalSalary += p.salary;
    }

    averageAge = averageAge / people.length;
```

**after**
```js
    let totalSalary = 0;
    for (const p of people) {
    totalSalary += p.salary;
    }

    let averageAge = 0;

    for (const p of people) {
    averageAge += p.age;
    }

    averageAge = averageAge / people.length;
```

[출처](https://yohanpro.com/posts/refactoring/split-loop)


### 14. 성의없는 요소
보통 개발을 할 때 프로프램 요소(클래스, 인터페이스 ..)를 이용하는 걸 좋아하는데, 이 구조가 필요가 없을 때도 있다. 
-> 필요가 없어지면 프로그램 요소는 고이보내드리는게 좋다!

### 15. 추측성 일반화
별로 하는 일이 없는 추상 클래스는 계층합치기를 통해 상속관계를 없애자.
불필요한 위임은 inline class로 제거해라.

### 16. 임시 필드
특정 상황에서만 값이 설정되어있는 필드를 가진 클래스가 있다. 그렇지만 객체를 가져올 때 모든 필드가 채워져있으리라고 기대하는게 보통이다. 
-> 덩그러니 떨어져있는 필드들을 발견하면 클래스 추출하기로 제 살곳을 찾아주고, 함수 옮기기로 임시 필드들과 관련된 코드를 모조리 새 클래스에 몰아넣는다.
-> 임시필드들이 유효한지 확인 후 동작하는 조건부 로직에 대해서는 `특이 케이스 추가하기`로 필드들이 유효하지 않을 때를 위한 대안 클래스를 만들어 제거한다.

### 17. 메시지 체인
메시지 체인이란 클라이언트가 한 객체를 통해 다른 객체를 얻은 뒤 방금 얻은 객체에 또 다른 객체를 요청하는 식으로, 다른 객체를 요청하는 작업이 **연쇄적** 으로 이어지는 코드를 의미한다. 이 경우 내비게이션 중간 단계를 수정하면 클라이언트 코드도 수정해야한다.
-> `위임 숨기기` 를 통해 해결할 수 있다.

before
```
    managerName = aPerson.department.manager.name;
```

after
```
    managerName = aPerson.department.managerName; // 관리자 객체 (manager)의 존재를 숨김
    managerName = aPerson.manager.name; // 부서 객체의 존재를 숨김 
    managerName = aPerson.managerName; // 부서 객체와 관리자 객체 모두의 존재를 숨김
```

### 18. 중개자
객체의 대표적인 기능 중 하나로 캡슐화(외부로부터 세부사항을 숨겨줌)가 있다. 캡슐화하는 과정에서는 위임이 자주 활용된다.
클래스가 제공하는 메서드 중 절반이 다른 클래스에 구현을 위임하고 있다면 `중재자 제거하기`를 활용하여 실제로 일을 하는 객체와 직접 소통하게 하자.
-> 위임 메서드를 제거한 후 남는 일이 거의 없다면 호출하는 쪽으로 인라인하자

### 19. 내부자 거래
모듈 사이에 벽을 두껍게 세워 결합도를 낮춰야한다.

ex) 상속구조
자식클래스는 부모 클래스가 공개하고 싶은 것 이상으로 부모에 대해 알려고 한다. 그러다가 부모 품을 떠날 때가 온다면 `서브클래스를 위임으로 바꾸기`나 `슈퍼클래스를 위임으로 바꾸기`를 활용하자

### 20. 거대한 클래스
한 클래스가 너무 많은 일을 하려다보면 필드 수가 상당히 늘어난다.
그리고 클래스에 필드가 너무 많으면 중복 코드가 생기기 쉽다.
-> 클래스 추출하기로 필드들 일부를 따로 묶는다.
-> 클래스가 항시 모든 필드를 사용하지는 않을 수도 있는데 이럴 때는 앞에서 언급한 추출 기법들을 사용한다.

### 21. 서로 다른 인터페이스의 대안 클래스들
클래스의 장점을 필요에 따라 언제든 다른 클래스로 교체할 수 있다는 점이다.
단 교체하려면 인터페이스가 같아야한다.
-> 함수 선언 바꾸기로 메서드 시그니처를 일치시킨다.
-> 이로도 부족하면 함수 옮기기르 ㄹ이용하여 인터페이스가 같아질 때까지 필요한 동작들을 클래스 안으로 밀어넣는다.
그러다 대안 클래스들 사이에 중복 코드가 생기면 슈퍼클래스 추출하기를 적용할 지 고려해본다.


### 22. 데이터 클래스
데이터 클래스 : 데이터 필드와 게터/세터 메서드로만 구성된 클래스
-> 그저 데이터 저장 용도로마 ㄴ쓰이니 다른 클래스가 함부로 다루지 못하도록 `레코드 캡슐화하기` 로 숨기자.
-> 변경하면 안되는 필드는 `세터 제거하기`로 접근을 봉쇄한다.

또, 불변 필드는 굳이 캡슐화할 필요없고, 불변 데이터로부터 나오는 정보는 게터를 통하지 않고 그냥 필드 자체를 공개해도 된다.

### 23. 상속 포기
서브클래스가 부모의 동작은 필요로 하지만 인터페이스를 따르고 싶지 않을 때, 서브클래스를 위임으로 바꾸기나 슈퍼클래스를 위임으로 바꾸기를 활용해서 상속 메커니즘에서 벗어나자

### 24. 주석
주석이 장황하게 달린 원인은 주로 코드를 잘못 작성했기 때문이다.
그렇지만 주석이 무조건 나쁜 것은 아니다. 우선 주석을 남겨야겠다는 생각이 들면 주석이 필요없는 코드로 리팩토링해보는 것이 좋다.

그렇지만, 뭘 해야 할 지 모를 때라면 주석을 남기는 것이 좋다. 현재 진행 상황뿐 아니라 확실하지 않은 부분에 주석을 남기면 추후에 코드를 수정해야 할 프로그래머에게 도움이 된다.
