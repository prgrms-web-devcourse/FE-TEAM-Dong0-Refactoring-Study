# 리팩토링 3장
## 리팩토링을 해야 하는 경우
### 1. 기이한 이름
이름만 보고도 무슨 일을 하고 어떻게 사용해야 하는지 명확히 알 수 있어야한다.
-> 추후에 문맥 파악에 헤매는 시간을 크게 절약할 수 있다

### 2. 중복 코드
한 클래스에 따른 두 메서드가 똑같은 표현식을 사용한다면 `함수 추출하기`를 써서 양쪽 모두 추출된 메서드를 호출하게 바꾸면 된다.

### 3. 긴 함수

짧은 함수로 구성해야한다!
-> 🤔 오히려 왔다갔다 하면서 더 이해하기 힘들진 않을까?
호출과 선언을 동시에 보여주는 개발 환경을 활용하면 이 부담이 줄어들고, 이름을 잘 지어두면 본문 코드를 볼 이유가 사라진다! 그러므로 주석을 달아야 할 부분을 함수로 만들고, 동작 방식이 아닌 `의도` 가 드러나게 지으면 됨!

=> 함수 이름에 코드의 목적을 드러내고, 무엇을 하는지가 보여야한다

😮 추출해야하는 건 알겠는데 어떤 애들을 추출하지?
주석을 참고하면 쉽다. 주석을 찾으면 주석이 설명하는 코드와 함께 함수로 빼내고 함수 이름을 주석 내용을 토대로 지으면 좋다.


### 4. 긴 매개변수 목록
함수에 필요한 것들을 모조리 매개변수로 전달할 때 매개변수 목록이 길어질수록 이해하기 어려울 때가 많다 -> 객체 통째로 넘기기를 적용해 원본 데이터 구조를 그대로 전달한다.


### 5. 전역 데이터
전역 데이터는 코드 베이스 어디에서든 건드릴 수 있고 값을 누가 바꿨는지 찾아낼 메커니즘이 없다.
-> 변수 캡슐화하기
-> 데이터를 수정하는 부분을 쉽게 찾을 수 있고 접근을 통제할 수 있게 된다

### 6. 가변 데이터
함수형 프로그래밍은 데이터는 절대 변하지 않고, 데이터를 변경하려면 반드시 (원래 데이터는 그대로 둔 채) 변경하려는 값에 해당하는 복사본을 만들어서 반환한다는 개념을 기본으로 삼고 있다.

최대한 side effect를 줄이는 방향으로 코드를 작성해야한다.
-> 문장 슬라이스하기, 함수 추출하기를 이용해서 무언가를 갱신하는 코드로부터 부작용이 없는 코드를 분리한다. 

### 7. 뒤엉킨 변경
맥락별로 처리하는 것이 좋다.
만약, 순차적으로 처리되는 로직이라면 단계를 분리한다. (단계 쪼개기)
전체 처리 과정 곳곳에서 각기 다른 맥락의 함수를 호출하는 빈도가 높다면, 각 맥락에 해당하는 적당한 모듈들을 만들어서 관련 함수들을 모은다. 그러면 처리 과정이 맥락별로 구분된다.

### 8. 산탄총 수술
함께 변경되는 대상들을 함수 옮기기와 필드 옮기기로 모두 한 모듈에 묶어둔다.
어설프게 분리된 로직을 함수 인라인하기나 클래스 인라인하기같은 인라인 리팩터링의로 하나로 합치는 것도 좋다.

### 9. 기능 편애
프로그램을 모듈화할 때 코드를 여러 영역으로 나눈 뒤 영역 안에서 이뤄지는 상호작용은 최대한 늘리고 영역 사이에서 이뤄지는 상호작용은 최소로 줄이는 데 주력한다.

함께 변경할 대상을 한데 모은다.

### 10. 데이터 뭉치
필드 형태의 데이터 뭉치를 찾아서 클래스 추출하기로 하나의 객체로 묶는다. 
데이터뭉치인지 판별하려면 값 하나를 삭제해보고, 나머지 데이터만으로 의미가 없다면 객체로 환생하길 갈망하는 데이터 뭉치라는 의미이다.

### 11. 기본형 집착
기본형 -> 객체로 바꿔야한다.
클래스 추출하기와 매개변수 만들기를 이용하면 된다.

### 12. 반복되는 switch 문
중복된 switch 문은 조건절 하나 추가할 때마다 다른 switch 문들도 모두 찾아서 함께 수정해야 하기 때문이다.

### 13. 반복문
반복문을 파이프라인(filter, map)으로 바꾸기를 적용해서 반복문을 제거한다. 

### 14. 성의없는 요소
