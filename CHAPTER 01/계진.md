# 1장

## 들어가며

- 리팩터링 : 겉으로 드러나는 코드의 기능은 바꾸지 않으면서 내부 구조를 개선하는 방식으로 소프트웨어 시스템을 개선하는 과정
  - 코드 완성 후 설계를 개선

## 1.1 자, 시작해보자!, 1.2 예시 프로그램을 본 소감

- 영수증 출력 프로그램

  - `plays.json`(연극 정보), `invoices.json`(공연로 청구서), `statement()`(청구서 출력)

- 프로그램이 새로운 기능을 추가하기에 편한 구조가 아니면, 리팩터링으로 형태를 먼저 바꾸고 기능을 추가한다.

- 수정할 부분
  1. 청구 내역 HTML 출력
  2. 다양한 장르 추가 가능성
     - `statement()` 수정 필요

## 1.3 리팩터링의 첫 단계, 1.4 statement() 함수 쪼개기, 1.5 중간 점검: 난무하는 중첩 함수

- 과정
  1. 리팩터링을 검사해줄 테스크 코드 마련
  2. 조금씩 변경하는 리팩터링 후 바로 테스트해서 확인
  3. 한 번의 리팩터링이 끝나면 commit, 모이면 push
- 긴 함수를 리팩터링할 때는 전체 동작을 각각의 부분으로 나눌 수 있는 지점 찾기(`amountFor`, 중첩함수로 구현)
  - `switch` : 한 번의 공연에 대한 요금만을 계산
    - 유효범위를 벗어나는 변수 체크 : `perf`, `play`, `thisAmount`
    - 새로 만들 함수에서도 변하지 않는 변수는 매개변수로, 변하는 변수는 만든 스코프에서 사용되도록 새로 선언 후 return
- 표현을 명확하게 : 사람이 이해하기 쉬운 코드로 만들기
  - `thisAmount` => `result`(함수의 반환값)
  - `perf` => `aPerformance`(매개변수의 역할이 뚜렷하지 않아 부정관사 붙임)
- 임시 변수를 질의 함수로 바꾸기
  - 추출이 쉬워짐
  - `play`는 `aPerformance`에 따라 바뀌는 임시 변수, 인라인으로 바로 함수 호출(`playFor(perf)`)
  - `play` 매개변수 제거 가능
  - for문의 perf 사용 부분 함수로 추출(`volumeCreditsFor(perf)`)
- 반복문 쪼개기(`volumeCredits`, `totalAmount`)

  - 반복문 로직 분리(누적 연산이 사용되는 곳, `volumeCredits += volumeCreditsFor(perf)`)
  - 변수 선언 위치를 반복문 앞으로 변경(상단=>중단)
  - 함수로 추출(`totalVolumeCredits()`)
  - 변수 쓰인 곳 인라인화 + 선언 제거

  - _반복문 중복 성능_?
    - 컴파일러의 발달로 여러 기법을 통해 최적화가 잘 되어 있기 때문에 반복문의 중복에 따르는 성능 저하는 미미하다.
    - 리팩터링을 통해 성능 저하가 눈에 띄더라도 리팩터링 후 성능 개선을 시도, 안 되면 돌아가기

- 골격을 모두 개선했다.
